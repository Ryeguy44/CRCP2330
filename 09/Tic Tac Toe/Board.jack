class Board {
	
 Array boardArray; // 0 vacant, 1 naught, 2 cross
 int boardX,boardY,boardSize,thickness,cellSize;
 int winThickness; // thickness of the line drawn in case of win!
 boolean isWin, isDraw;
 int winMode; // 0 - row, 1-col, 2 - topdiag, 3 - bottom diag
 int winRow,winCol;// winning row or column
 int freeCellCount; // how many cells are free?
	
	
	constructor Board new(int x,int y) {		
	 boardX = x;
	 boardY = y;
	 boardSize = 120;
	 thickness = 4;
	 winThickness = 4;
	 cellSize = boardSize/3;
	 boardArray = Array.new(9);
	 clearBoard();
	 drawBoardBorders();
		return this;
	}
	
 void dispose() {
	 Screen.setColor(false);
	 Screen.drawRectangle(boardX,boardY,boardX+boardSize, boardY+boardSize);
	 Screen.setColor(true);
	 Memory.deAlloc(boardArray);
		return;
	}
	
 void clearBoard() {
		 int i;
	 freeCellCount = 9;
	 isWin = false;
	 isDraw  = false;
		while(i<9) {
		 boardArray[i] = 0;
		 i = i + 1;
		}
		return;
	}
	
	// convert row/col to the array index
 int posToIndex(int row, int col) {
		return (row*3)+col;
	}
	
	// is the selected row/col free of pieces?
 boolean isFree(int row, int col) {
		if(boardArray[posToIndex(row,col)]=0) {
			return true;
		}else {
			return false;
		}
	}
	
	// convert row to pixel y for drawing
 int rowToY(int r) {
		return boardY + (r*cellSize);
	}
	
 int colToX(int c) {
		return boardX + (c*cellSize);
	}
	
 void drawBoardBorders() {
		 int offset;
	 offset = thickness/2;
		// vertical lines
	 Screen.drawRectangle(boardX+cellSize-offset,boardY, boardX+cellSize+offset,boardY+boardSize);
	 Screen.drawRectangle(boardX+(2*cellSize)-offset,boardY, boardX+(2*cellSize)+offset,boardY+boardSize);
		// horizontal lines
	 Screen.drawRectangle(boardX,boardY+cellSize-offset, boardX+boardSize,boardY+cellSize+offset);
	 Screen.drawRectangle(boardX,boardY+(2*cellSize)-offset, boardX+boardSize,boardY+(2*cellSize)+offset);
		return;
	}
	
	// draw win for rows
 void drawRowWin(int r) {
		 int y,offset;
	 y = rowToY(r)+(cellSize/2); 
	 offset = winThickness/2;
	 Screen.drawRectangle(boardX, y-offset, boardX+boardSize,y+offset);
		return;
	}
	
	// draw win for columns
 void drawColWin(int c) {
		 int x,offset;
	 x = colToX(c)+(cellSize/2); 
	 offset = winThickness/2;
	 Screen.drawRectangle(x-offset,boardY, x+offset,boardY+boardSize);
		return;
	}
	
	// draw diagonal win
 void drawTopDiagonalWin() {
		 int i,x,y;
	 x = boardX;
	 y = boardY;
	 i = winThickness-1;
		while(~(i<0)) {
		 Screen.drawLine(x+i,y,x+boardSize,y+boardSize-i);
		 Screen.drawLine(x,y+i,x+boardSize-i,y+boardSize);
			
		 i = i-1;
		}
		return;
	}
	
	// draw diagonal win
 void drawBottomDiagonalWin() {
		 int i,x,y;
	 x = boardX;
	 y = boardY;
	 i = winThickness-1;
		while(~(i<0)) {
		 Screen.drawLine(x,y+boardSize-i,x+boardSize-i,y);
		 Screen.drawLine(x+i,y+boardSize,x+boardSize,y+i);
			
		 i = i-1;
		}
		return;
	}
	
	
 void drawWin() {
		if(winMode=0) {
		 drawRowWin(winRow);
		}
		if(winMode=1) {
		 drawColWin(winCol);
		}
		if(winMode=2) {
		 drawTopDiagonalWin();
		}
		if(winMode =3) {
		 drawBottomDiagonalWin();
		}
		return;
	}
	
 boolean isWin() {
		return isWin;
	}
	
 boolean isDraw() {
		return isDraw;
	}
	
	// evaluate board to find draw or win
 void evaluateBoard() {
		 int r,c,b1,b2,b3;
	 r = 0;
	 c = 0;
	 isWin = false;
	 isDraw = false;
				
		while(r<3) {
		 b1 = boardArray[posToIndex(r,0)];
		 b2 = boardArray[posToIndex(r,1)];
		 b3 = boardArray[posToIndex(r,2)];
			if((b1=b2) & (b2=b3) & (b1>0)) {
			 isWin = true;
			 winMode = 0;
			 winRow = r;
				return;
			}
		 r = r+1;
		}
		while(c<3) {
		 b1 = boardArray[posToIndex(0,c)];
		 b2 = boardArray[posToIndex(1,c)];
		 b3 = boardArray[posToIndex(2,c)];
			if((b1=b2) & (b2=b3)& (b1>0)) {
			 isWin = true;
			 winMode = 1;
			 winCol = c;
				return;
			}
		 c = c+1;
		}
		
	 b1 = boardArray[0];
	 b2 = boardArray[4];
	 b3 = boardArray[8];
		if((b1=b2) & (b2=b3)& (b1>0)) {
		 isWin = true;
		 winMode = 2;
			return;
		}
		
	 b1 = boardArray[6];
	 b2 = boardArray[4];
	 b3 = boardArray[2];
		if((b1=b2) & (b2=b3)& (b1>0)) {
		 isWin = true;
		 winMode = 3;
			return;
		}
		
		// if no win and also no further moves, we have a draw!
		if(freeCellCount=0) {
		 isDraw = true;
			return;
		}
		
		return ;
	}
	
	
	
 void drawMove(int row, int col,Piece p) {
		 int xl,yt;
	 xl = colToX(col) + ((cellSize-p.getWidth())/2);
	 yt = rowToY(row) + ((cellSize-p.getHeight())/2);
	 p.drawPiece(xl,yt);
		return;
	}
	
	// make a move en't draw the move on screen)
 void makeMove(int row, int col, Piece p) {
	 boardArray[posToIndex(row,col)] = p.getType();
	 freeCellCount = freeCellCount-1;
		return;
	}
	
	// take back the move
 void takeBackMove(int row, int col,Piece p) {
	 boardArray[posToIndex(row,col)] = 0;
	 freeCellCount = freeCellCount + 1;
		return;
	}
	
	
 int getFreeCellCount() {
		return freeCellCount;
	}
	
 Array getAvailableMoves() {
		 Array moves;
		 int r1,c1,counter;
	 r1 = 0;
	 c1 = 0;
	 moves = Array.new(freeCellCount*2);
	 counter = 0;
		while(r1<3) {
		 c1 = 0;
			while(c1<3) {
				if(boardArray[posToIndex(r1,c1)]=0) {
				 moves[counter] = r1;
				 moves[counter+1] = c1;
				 counter = counter + 2;
				}
			 c1 = c1 + 1;
			}
		 r1 = r1 + 1;
		}
		return moves;
	}
}