class TicTacToeGame {
	 Board board;
	 Piece nPiece,cPiece;
	 int callCounter;
	 boolean isDisplay;
	 int p1;
	
	 init() {
	 InputUtil.init();
	 nPiece = Piece.new(1);
	 cPiece = Piece.new(2);
		return;
	}
	
	 resetStat() {
	 p1 =0;
		return;
	}
	 incStat() {
	     String s;
	 p1 = p1+1;
		if(p1=1) {
		    InputUtil.showMessage("Thinking... /");
			return;
		}
		if(p1=100) {
		 InputUtil.showMessage("Thinking... -");
			return;
		}
		if(p1=200) {
		 InputUtil.showMessage("Thinking... \\");
			return;
		}
		if(p1=300) {
		 InputUtil.showMessage("Thinking... |");
			return;
		}

		if(p1=400) {
		 p1 = 0;
		}
		return;
	}
	
	// 1-continue, 2-draw and 3-win;
	 int processBoard() {
	 board.evaluateBoard();
		if(board.isWin()) {
		 board.drawWin();
		}
		
		if(board.isWin()) {
			return 3;
		}
		if(board.isDraw()) {
			return 2;
		}
		
		return 1;
	}
	
	// 0-quit, 1-continue, 2-draw, 3-win
	 int play(int player,Piece p) {
		 boolean validPlayerInput;
		 int input;
		 Array playerMove,computerMove;
	 validPlayerInput = false;
		
		if(player=0) { // human
		
			while(~validPlayerInput) { // the player input must be valid!
			 input = InputUtil.readInput("Enter move (1 to 9 or 0 to restart):");
				if(input=0) {
					return 0; // restart game!
				}
			 playerMove = TicTacToeGame.inputToMove(input);
			 validPlayerInput = board.isFree(playerMove[0],playerMove[1]);
			}
			
		 board.makeMove(playerMove[0],playerMove[1],p);
		 board.drawMove(playerMove[0],playerMove[1],p);
		 playerMove.dispose();
			return TicTacToeGame.processBoard();
		}else {
		 computerMove = TicTacToeGame.getComputerMove(p);
		 board.makeMove(computerMove[0],computerMove[1],p);
		 board.drawMove(computerMove[0],computerMove[1],p);
		 computerMove.dispose();
			return TicTacToeGame.processBoard();
		}
	}
	
	 startGame() {
		 int currentPlayer,currentPiece; //  0 for you and 1 for computer
		 boolean gameOver;
		 int gameStatus;
	 TicTacToeGame.showCredits();
		
	 InputUtil.showMessage("Press enter to start the game!");
	 TicTacToeGame.seedGame();

		while(true) {
		 currentPlayer = InputUtil.waitForZeroOrOne("First move? (0 for you, 1 for computer): ");
		 currentPiece = cPiece;
		
		 board = Board.new(200,60);
		 gameOver = false;
			while(~gameOver) {
			 gameStatus = TicTacToeGame.play(currentPlayer,currentPiece);
				
				if(gameStatus=0) {
				 gameOver = true;
				}
				if(gameStatus=1) {
				 currentPlayer = TicTacToeGame.getOtherPlayer(currentPlayer);
				 currentPiece = TicTacToeGame.getOtherPiece(currentPiece);
				}
				if(gameStatus=2) {
				 InputUtil.showMessage("Game drawn! Press enter to restart!");
				 TicTacToeGame.seedGame();
				 gameOver = true;
				}
				if(gameStatus = 3) {
					if(currentPlayer=0) {
						// this never happens! :-)
					 InputUtil.showMessage("Congratulations! You won the game!");
					}else {
					 InputUtil.showMessage("Sorry! You lost the game! Press enter to restart!");
					}
				 TicTacToeGame.seedGame();
				 gameOver = true;
				}
			}
		 board.dispose();// start with a new board!
		}
	
		return;
	}
	
	 Array getComputerMove(Piece p) {
		 Array moves;
		 Array movesWithScore;
	 TicTacToeGame.resetStat();
	 moves = Array.new(2);
		if(board.getFreeCellCount()=9) {
			return TicTacToeGame.getRamGoodMove();
		}else {
		 movesWithScore = TicTacToeGame.getBestMove(p);
		 moves[0]=movesWithScore[1]; //ignore score!
		 moves[1] = movesWithScore[2];
		 movesWithScore.dispose();
			return moves;
		}
	}
	
	 Array getBestMove(Piece p) {
		 int i,moveCount, currentScore,nextScore;
		 Array moveList, bestMove;

	 i = 0;
	 currentScore = -10; // we always want to get a move!
		
	 bestMove=Array.new(3);
	 moveCount = board.getFreeCellCount();
	 moveList = board.getAvailableMoves();
		while(i< moveCount) {
		 TicTacToeGame.incStat();
		 board.makeMove(moveList[i+i],moveList[i+i+1],p);
		 nextScore = TicTacToeGame.getMoveScore(p);
			if(nextScore>currentScore) {
			 currentScore = nextScore;
			 bestMove[0] = currentScore;
			 bestMove[1] = moveList[i+i];
			 bestMove[2] = moveList[i+i+1];
			}
		 board.takeBackMove(moveList[i+i],moveList[i+i+1],p);
		 i = i+1;
		}
	 moveList.dispose();
		return bestMove;
	}
	
	 int getMoveScore(Piece p) {
		 Array otherMove;
		 int otherScore;
	 board.evaluateBoard();
		if(board.isDraw()) {
			return 0;
		}
		if(board.isWin()) {
			return 1;
		}
	 otherMove= TicTacToeGame.getBestMove(TicTacToeGame.getOtherPiece(p));
	 otherScore = otherMove[0];
	 otherMove.dispose();
		return -otherScore;		
	}
	
	
	 int getOtherPiece(Piece p) {
		if(p = nPiece) {
			return cPiece;
		}else {
			return nPiece;
		}
	}
	
	 int getOtherPlayer(int p) {
		if(p=0) {
			return 1;
		}else {
			return 0;
		}
	}
	
	// get a ram corner/center move.
	// used by computer for first move as first move search is very expensive!
	 Array getRamGoodMove() {
		 int v;
		 Array moves;
		while(true) {
		 v = Ram.randRange(4);
		 v = (v*2)+1; // logic for corner pos
		 moves = TicTacToeGame.inputToMove(v);
			if(board.isFree(moves[0],moves[1])) {
				return moves;
			}
		}
		return moves;
	
	}
	
	// get a ram move!
	 Array getRamMove() {
		 int v;
		 Array moves;
		while(true) {
		 v = Ram.randRange(8)+1;
		 moves = TicTacToeGame.inputToMove(v);
			if(board.isFree(moves[0],moves[1])) {
				return moves;
			}
		}
		return moves;
	}
	
	
	
	
	 Array inputToMove(int input) {
		 Array moves;
	 moves = Array.new(2);
	 moves[0] = (input-1)/3 ; //row;
	 moves[1] = (input-1)-(3*moves[0]);
		return moves;
		
	}
	
	 seedGame() {
		 int seedCounter;
		 boolean enterPressed;
	 enterPressed = false;
	 seedCounter = 1;
		while(~enterPressed) {
			if(Keyboard.keyPressed()=128) {
			 enterPressed = true;
			}
		 seedCounter = seedCounter+1;
			if(seedCounter > 25444) {
			 seedCounter = 1;
			}
		}
	 Ram.setSeed(seedCounter);
		return;
	}
	
	 showCredits() {
	 Output.moveCursor(20,16);
	 Output.printString("Tic Tac Toe in Jack Language");
	 Output.moveCursor(21,22);
	 Output.printString("By Jayson Joseph");
		return;
	}
	
}